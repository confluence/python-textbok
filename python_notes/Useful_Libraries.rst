**************************************
Useful modules in the Standard Library
**************************************

Python comes with a built-in selection of modules which provide commonly used functionality.  We have encountered some of these modules in previous chapters -- for example, ``itertools``, ``logging``, ``pdb`` and ``unittest``.  We will look at a few more examples in this chapter.  This is only a brief overview of a small subset of the available modules --  you can see the full list, and find out more details about each one, by reading the `Python Standard Library documentation <http://docs.python.org/3.3/library/index.html>`_.

Date and time: ``datetime``
===========================

The ``datetime`` module provides us with objects which we can use to store information about dates and times:

* ``datetime.date`` is used to create dates which are not associated with a time.
* ``datetime.time`` is used for times which are independent of a date.
* ``datetime.datetime`` is used for objects which have both a date and a time.
* ``datetime.timedelta`` objects store *differences* between dates, times or datetimes -- if we subtract one datetime from another, the result will be a timedelta.
* ``datetime.timezone`` objects represent time zone adjustments as offsets from UTC.  This class is a subclass of ``datetime.tzinfo``, which is not meant to be used directly.

We can query these objects for a particular component (like the year, month, hour or minute), perform arithmetic on them, and extract printable string versions from them if we need to display them.  Here are a few examples::

    import datetime

    # this class method creates a datetime object with the current date and time
    now = datetime.datetime.today()

    print(now.year)
    print(now.hour)
    print(now.minute)

    print(now.weekday())

    long_ago = datetime.datetime(1999, 3, 14, 12, 30, 58)

    print(long_ago) # remember that this calls str automatically
    print(long_ago < now)

    difference = now - long_ago
    print(type(difference))
    print(difference) # remember that this calls str automatically

.. Todo:: a simple exercise? Something that involves an absolute difference between datetimes, not like age.

Mathematical functions: ``math``
================================

The ``math`` module is a collection of mathematical functions.  They can be used on floats or integers, but are mostly intended to be used on floats, and usually return floats.  Here are a few examples::

    import math

    # These are constant attributes, not functions
    math.pi
    math.e

    # round a float up or down
    math.ceil(3.3)
    math.floor(3.3)

    # natural logarithm
    math.log(5)
    # logarithm with base 10
    math.log(5, 10)
    math.log10(5) # this function is slightly more accurate

    # square root
    math.sqrt(10)

    # trigonometric functions
    math.sin(math.pi/2)
    math.cos(0)

    # convert between radians and degrees
    math.degrees(math.pi/2)
    math.radians(90)

If you need mathematical functions to use on complex numbers, you should use the ``cmath`` module instead.

Pseudo-random numbers: ``random``
=================================

We call a sequence of numbers *pseudo-random* when it appears in some sense to be random, but actually isn't.  Pseudo-random number sequences are generated by some kind of predictable algorithm, but they possess enough of the properties of truly random sequences that they can be used in many applications that call for random numbers.

It is difficult for a computer to generate numbers which are genuinely random.  It is possible to gather truly random input using hardware, from sources such as the user's keystrokes or tiny fluctuations in voltage measurements, and use that input to generate random numbers, but this process is more complicated and expensive than pseudo-random number generation, which can be done purely in software.

Because pseudo-random sequences aren't actually random, it is also possible to reproduce the exact same sequence twice.  That isn't something we would want to do by accident, but it is a useful thing to be able to deliberately while debugging software, or in an automated test.

In Python can we use the ``random`` module to generate pseudo-random numbers, and do a few more things which depend on randomness.  The core function of the module generates a random float between 0 and 1, and most of the other functions are derived from it.  Here are a few examples::

    import random

    # a random float from 0 to 1 (excluding 1)
    random.random()

    pets = ["cat", "dog", "fish"]
    # a random element from a sequence
    random.choice(pets)
    # shuffle a list (in place)
    random.shuffle(pets)

    # a random integer from 1 to 10 (inclusive)
    random.randint(1, 10)

When we load the ``random`` module we can *seed* it before we start generating values.  We can think of this as picking a place in the pseudo-random sequence where we want to start.  We normally want to start in a different place every time -- by default, the module is seeded with a value taken from the system clock.  If we want to reproduce the same random sequence multiple times -- for example, inside a unit test -- we need to pass the same integer or string as parameter to ``seed`` each time:

    # set a predictable seed
    random.seed(3)
    random.random()
    random.random()
    random.random()

    # now try it again
    random.seed(3)
    random.random()
    random.random()
    random.random()

    # and now try a different seed
    random.seed("something completely different")
    random.random()
    random.random()
    random.random()

Matching string patterns: ``re``
================================

Parsing CSV files: ``csv``
==========================

Writing scripts: ``sys`` and ``argparse``
=========================================

Interacting with the operating system: ``os``
=============================================



* sqlite? xml parsing? Something to do with the web? Put all this in one section?